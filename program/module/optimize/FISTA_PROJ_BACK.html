<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>MSWiki</title>
    <link rel="stylesheet" href="./../../program_css/reset.css">
    <link rel="stylesheet" href="./../../program_css/style.css">
    <link rel="stylesheet" href="./../../../icon/bootstrap/icons-1.8.3/font/bootstrap-icons.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/default.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>

    <header class="ly_header">
        <div class="ly_header_inner">
            <nav class="bl_tabNav">
                <ul class="bl_tabNav_inner">
                    <li><a class="bl_tabNav_link" href="./../../index.html">ホーム</a></li>
                    <li><a class="bl_tabNav_link is__active" href="./../../CSDprogram.html">CSDプログラム</a></li>
                    <li><a class="bl_tabNav_link" href="./../../MSprogram.html">MSプログラム</a></li>
                    <li><a class="bl_tabNav_link" href="./../../FAQ.html">FAQ</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="ly_main">

        <h1>加速射影勾配法(FISTA with Backtracking)</h1>

        <div class="ly_contWrapper">

            <div class="bl_pageCT">
                <ul>
                    <li><a href="#module">必要モジュール</a></li>
                    <li><a href="#input">入力</a></li>
                    <li><a href="#output">出力</a></li>
                    <li><a href="#code">コード</a></li>
                    <li><a href="#example">使用例</a></li>
                </ul>
            </div>

            <div class="ly_conts">

                <div class="bl_cont" id="module">
                    <h2>必要モジュール</h2>
                    <div class="bl_cont_txt">
                        <ul>
                            <li><a href="https://numpy.org/">NumPy</a></li>
                            <li><a href="https://pandas.pydata.org/">Pandas</a></li>
                            <li><a href="https://docs.python.org/ja/3/library/time.html">time</a></li>
                            <li><a href="https://www.sqlalchemy.org/">sqlalchemy</a></li>
                            <li><a href="https://docs.python.org/ja/3/library/os.html">os</a></li>
                        </ul>
                    </div>
                </div>


                <div class="bl_cont" id="input">
                    <h2>入力</h2>
                    <div class="bl_cont_txt">

                        <ul>
                            <li>目的関数(必須)：function:obj_func．入力が [ndarray:x] で，出力が [float:obj, float:time] の関数．</li>
                            <li>勾配関数(必須)：function:nbl_func．入力が [ndarray:x] で，出力が [ndarray:nbl, float:time] の関数．</li>
                            <li>射影関数(必須)：function:proj_func．入力が [ndarray:x] で，出力が [ndarray:x, float:time] の関数．</li>
                            <li>初期解(必須)：ndarray:x</li>
                            <li>初期リプシッツ定数(必須)：float:lips_init</li>
                            <li>収束判定値(必須)：float:conv_judge</li>
                            <li>出力頻度：int:output_iter．デフォルトは100．</li>
                            <li>出力url：str:output_url．デフォルトは設定なし．</li>
                        </ul>
                
                    </div>
                </div>

                <div class="bl_cont" id="output">
                    <h2>出力</h2>
                    <div class="bl_cont_txt">

                        <ul>
                            <li>
                                計算結果：pandas.DataFrame:output_data
                                <ul class="ly_ul2">
                                    <li>iteration：int．反復回数．</li>
                                    <li>time：float．累計処理時間(elapse time)．</li>
                                    <li>now_obj：float．目的関数値．</li>
                                    <li>now_conv：float．収束判定値．</li>
                                    <li>now_lips：float．リプシッツ定数．</li>
                                    <li>num_call_obj：int．目的関数の呼び出し回数．</li>
                                    <li>num_call_nbl：int．勾配関数の呼び出し回数．</li>
                                    <li>num_call_proj：int．射影関数の呼び出し回数．</li>
                                </ul>
                            </li>
                        </ul>

                    </div>
                </div>

                <div class="bl_cont" id="code">
                    <h2>コード</h2>
                    <div class="bl_cont_txt">


                        <div class="bl_codeWrapper">
                            <span class="el_codeWrapper_rang">Python</span>
                            <pre class="el_codeWrapper_code">
<code>import numpy as np
import time
import os
from sqlalchemy import null
import pandas as pd


class FISTA_PROJ_BACK:

    # 初期設定
    def __init__(self):
        # 結果格納用
        self.iter = null
        self.sol = null
        self.sol_obj = null
        self.num_call_nbl = null
        self.num_call_obj = null
        self.num_call_conv = null
        self.num_call_proj = null
        self.lips = null
        self.para_time = null
        self.total_time = null
        # 演算等に必要なデータ
        self.obj_func = null
        self.nbl_func = null
        self.proj_func = null
        self.conv_func = null
        self.lips_init = null
        self.x_init = null
        self.conv_judge = null
        self.back_para = null
        self.output_iter = 100
        # 結果格納用のデータセット
        self.output_data = null
        self.output_root = null

    # 目的関数と勾配関数を設定(関数の引数はベクトルのみ)
    def set_obj_func(self, obj_func):
        self.obj_func = obj_func

    def set_nbl_func(self, nbl_func):
        self.nbl_func = nbl_func

    def set_proj_func(self, proj_func):
        self.proj_func = proj_func

    def set_conv_func(self, conv_func):
        self.conv_func = conv_func

    # 計算に必要な各種設定をsetting
    def set_lips_init(self, lips_init):
        self.lips_init = lips_init

    def set_output_iter(self, iter):
        self.output_iter = iter

    def set_conv_judge(self, conv):
        self.conv_judge = conv

    def set_back_para(self, para):
        if para <= 1.0: 
            sprint("backtracking parameter is rather than 1.") 
            return 0 
        self.back_para = para 
        
    def set_x_init(self, x_init): 
        self.x_init=x_init 
        
    def set_output_root(self, root): 
        self.output_root=root 
        
    # FISTA with backtracking 
    def exect_FISTA_proj_back(self): 
        is_Executed = 0 
        print("\n\n") 
        if self.x_init is null: 
            print("init sol is not set.")
            is_Executed = -1 
        if self.obj_func is null: 
            print("objective function is not set.") 
            is_Executed = -1 
        if self.nbl_func is null: 
            print("nabla function is not set.") 
            is_Executed = -1 
        if self.proj_func is null: 
            print("projection function is not set.") 
            is_Executed = -1 
        if self.conv_func is null: 
            print("convergence function is not set.") 
            is_Executed = -1 
        if self.lips_init is null: 
            print("initial lipschitz constant (>0) is not set.")
            is_Executed = -1
        if self.back_para is null:
            print("backtracking parameter is not set.")
            is_Executed = -1
        if self.conv_judge is null:
            print("convergence judgement (>0) is not set.")
            is_Executed = -1

        if is_Executed:
            print("FISTA with backtracking cannot be executed.\n\n")
            return -1

        print('start Accel Gradient Projection Method (FISTA with backtracking)!')

        # 初期状態の諸々を計算
        [now_obj, temp_para_time, temp_total_time] = self.obj_func(self.x_init)
        [now_conv, temp_para_time, temp_total_time] = self.conv_func(self.x_init)

        output_data = pd.DataFrame([[0, 0.0, now_obj, now_conv, self.lips_init, 0, 0, 0]], columns=['iteration', 'time', 'now_obj', 'now_conv', 'now_lips', 'num_call_obj', 'num_call_nbl', 'num_call_proj'])
        if self.output_root != null:
            output_data.to_csv(os.path.join(self.output_root, 'result.csv'))


        # 初期設定（反復回数・勾配関数の呼び出し回数を初期化）
        iteration = 0
        num_call_obj = 0
        num_call_nbl = 0
        num_call_conv = 0
        num_call_proj = 0
        now_lips = self.lips_init

        # 解の更新で使用する値
        t = 1.0
        j = 0

        # 初期解の設定
        now_sol = self.x_init.copy()

        temp_sol = now_sol.copy()

        # 計算時間格納用変数
        total_time = 0.0

        if len(now_sol) > 5:
            print('iteration:', iteration, ' now_sol:', now_sol[:5], ' now_obj:', now_obj, ' convergence:', now_conv)
        else:
            print('iteration:', iteration, ' now_sol:', now_sol, ' now_obj:', now_obj, ' convergence:', now_conv)


        while 1:

            iteration += 1

            # 勾配計算（一時的な解の）
            [temp_nbl, temp_time] = self.nbl_func(temp_sol)
            total_time += temp_time
            num_call_nbl += 1

            # backtracking
            [now_lips, temp_call_obj, temp_call_nbl, temp_call_proj, temp_time] = self.backtracking(temp_sol, now_lips)
            total_time += temp_time
            num_call_obj += temp_call_obj
            num_call_nbl += temp_call_nbl
            num_call_proj += temp_call_proj

            # 暫定解の更新
            prev_sol = now_sol
            [now_sol, temp_time] = self.proj_func(temp_sol - temp_nbl/now_lips)
            total_time += temp_time
            num_call_proj += 1

            # 目的間数値の計算(必ずしも必要ない)
            prev_obj = now_obj
            [now_obj, temp_time] = self.obj_func(now_sol)
            total_time += temp_time
            num_call_obj += 1

            start_time = time.process_time()
            prev_t = t
            t = (1.0 + (1.0 + 4.0*prev_t**2.0)**(1.0/2.0))/2.0
            j += 1
            temp_sol = now_sol + ((prev_t - 1.0)/t) * (now_sol - prev_sol)
            if now_obj - prev_obj > 0 and j > 5:
                t = 1.0
                j = 0
            end_time = time.process_time()
            total_time += end_time - start_time

            # 収束判定の準備
            [conv, temp_time] = self.conv_func(now_sol)
            total_time += temp_time
            num_call_conv += 1

            if iteration % self.output_iter == 0:

                if len(now_sol) > 5:
                    print('iteration:', iteration, ' now_sol:', now_sol[:5], ' now_obj:', now_obj, ' convergence:', conv)
                else:
                    print('iteration:', iteration, ' now_sol:', now_sol, ' now_obj:', now_obj, ' convergence:', conv)

                add_df = pd.DataFrame([[iteration, total_time, now_obj, conv, now_lips, num_call_obj, num_call_nbl, num_call_proj]], columns=output_data.columns)
                output_data = output_data.append(add_df)
                if self.output_root != null:
                    output_data.to_csv(os.path.join(self.output_root, 'result.csv'))

            # 収束判定
            if conv < self.conv_judge: 
                break 
                
        self.sol = now_sol 
        self.iter = iteration 
        self.time = total_time
        self.num_call_obj=num_call_obj
        self.num_call_nbl = num_call_nbl 
        self.num_call_proj=num_call_proj 
        [self.sol_obj, dummy_time] = self.obj_func(self.sol) 
        if self.output_root !=null:
            np.savetxt(os.path.join(self.output_root, 'sol.csv' ), self.sol) 
            if iteration % self.output_iter != 0:
                add_df=pd.DataFrame([[self.iter, self.time, self.sol_obj, conv, now_lips, self.num_call_obj, self.num_call_nbl, self.num_call_proj]], columns=output_data.columns)
                output_data = output_data.append(add_df) 
                self.output_data = output_data
                output_data.to_csv(os.path.join(self.output_root, 'result.csv' )) 
                
        print('finish accel gradient projection method') 
        
        return 0 
        
        def backtracking(self, now_sol, now_lips): 
            
            total_time = 0.0
            
            [now_obj, temp_time] = self.obj_func(now_sol) 
            total_time += temp_time
            [now_nbl, temp_time] = self.nbl_func(now_sol) 
            total_time += temp_time 
            num_call_obj = 1 
            num_call_nbl = 1 
            num_call_proj = 0 
            start_time = time.process_time() 
            
            iota = 0 
            while 1: 
            
                [temp_sol, temp_time] = self.proj_func(now_sol - now_nbl/(self.back_para**iota * now_lips)) 
                num_call_proj += 1 
                end_time = time.process_time() 
                total_time += end_time - start_time 
                
                [F, temp_time] = self.obj_func(temp_sol)
                total_time += temp_time 
                num_call_obj += 1 
                
                start_time = time.process_time()
                now_nbl_nolm = np.dot(temp_sol-now_sol, temp_sol-now_sol) 
                Q = now_obj + np.dot(now_nbl, temp_sol - now_sol) + now_nbl_nolm * (self.back_para**iota*now_lips/2.0) 
                
                if F <= Q:
                    break

            iota += 1

            end_time = time.process_time()
            total_time += end_time - start_time

            return [self.back_para**iota*now_lips, num_call_obj, num_call_nbl, num_call_proj, total_time]
</code></pre>
                        </div>

                    </div>
                </div>

                <div class="bl_cont" id="example">
                    <h2>使用例</h2>
                    <div class="bl_cont_txt">

                        <div class="bl_codeWrapper">
                            <span class="el_codeWrapper_rang">Python</span>
                            <pre class="el_codeWrapper_code"><code># 目的関数
def obj_func(x):   
    start_time = time.process_time()
    obj = 0               
    for i in range(len(x)):
        obj += (x[i] - 5.0)**2.0    
    end_time = time.process_time()                    
    return obj, end_time-start_time
                            
# 勾配関数
def nbl_func(x):  
    start_time = time.process_time()
    nbl_vec = x*2.0 - 10.0          
    end_time = time.process_time()              
    return nbl_vec, end_time-start_time

# 射影関数
def proj_func(x):
    start_time = time.process_time()
    x = x.clip(0.0)
    end_time = time.process_time()
    return x, end_time-start_time
    
# 初期解                            
x_init = np.array([-20, 2, 3, 7, 8, 9, 0])
                    
                            fista = FISTA()
                            fista.set_x_init(x_init)
                            fista.set_obj_func(obj_func)
                            fista.set_nbl_func(nbl_func)
                            fista.set_lips(1000)
                            fista.set_conv_judge(0.03)
                            fista.exect_FISTA()
                            
                            print('\n\n')
                            
                            print('sol: ', fista.sol)
                            print('sol_obj: ', fista.sol_obj)
                            print('iteration: ', fista.iter)
                            print('elapsed_time: ', fista.time)
                            print('num_call_nabla: ', fista.num_call_nbl)
                            
                            fista_back = FISTA_BACK()
                            fista_back.set_x_init(x_init)
                            fista_back.set_obj_func(obj_func)
                            fista_back.set_nbl_func(nbl_func)
                            fista_back.set_lips_init(0.01)
                            fista_back.set_back_para(1.1)
                            fista_back.set_conv_judge(0.03)
                            fista_back.set_output_iter(1)
                            fista_back.exect_FISTA_back()
                            
                            print('\n\n')
                            
                            print('sol: ', fista_back.sol)
                            print('sol_obj: ', fista_back.sol_obj)
                            print('iteration: ', fista_back.iter)
                            print('elapsed_time: ', fista_back.time)
                            print('num_call_nabla: ', fista_back.num_call_nbl)
                            print('num_call_obj: ', fista_back.num_call_obj)
</code></pre>
                        </div>
                
                    </div>
                </div>

            </div>

        </div>

    </main>


</body>

</html>